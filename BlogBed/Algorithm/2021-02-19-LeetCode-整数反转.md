---
title: 整数反转
date: 2021-02-19
categories: 算法
tags: ['算法', 'LeetCode']
article_header:
  type: cover
---

### 题目

给你一个32位的有符号整数x，返回x中每位上的数字反转后的结果。  
如果反转后整数超过32位的有符号整数的范围[−231, 231 − 1]，就返回0。  
假设环境不允许存储64位整数（有符号或无符号）。

#### 示例1

输入：x = 123  
输出：321

#### 示例2

输入：x = -123  
输出：-321

#### 示例3

输入：x = 120  
输出：21

#### 示例4

输入：x = 0  
输出：0

#### 提示

-231 <= x <= 231 - 1

> 链接：<https://leetcode-cn.com/problems/reverse-integer>

### 题解

#### 题解1

逐位分析，将负数转成整数，统一处理

```csharp
public class Solution {
    public int Reverse(int x)
    {
        if (x == int.MinValue)  // 确保下面去绝对值时，不会异常
            return 0;

        int result = 0;

        int symbol = 1;
        if (x < 0) symbol = -1;
        x = Math.Abs(x);

        int i;
        while (x > 0)
        {
            i = x % 10;
            x /= 10;
            try
            {
                result = checked(result * 10 + i);  // 默认情况下，C＃整数运算不会在溢出时引发异常，这个是为了使其引发异常
            }
            catch (OverflowException)
            {
                result = 0;
                break;
            }
        }

        if (symbol == -1)
        {
            try
            {
                result = checked(result * -1);
            }
            catch (OverflowException)
            {
                result = 0;
            }
        }

        return result;
    }
}
```

#### 题解2

逐位分析，优化版

```csharp
public class Solution {
    public int Reverse(int x)
    {
        int result = 0;

        int i;
        while (x != 0)
        {
            i = x % 10;
            x /= 10;
            try
            {
                result = checked(result * 10 + i);
            }
            catch (OverflowException)
            {
                result = 0;
                break;
            }
        }

        return result;
    }
}
```

#### 题解3

逐位分析，借助List

```csharp
public class Solution {
    public int Reverse(int x)
    {
        int result = 0;

        List<int> digits = new List<int>();

        while (x != 0)
        {
            digits.Add(x % 10);
            x /= 10;
        }

        for (int i = 0; i < digits.Count; i++)
        {
            try
            {
                result = checked(result * 10 + digits[i]);
            }
            catch (OverflowException)
            {
                result = 0;
                break;
            }
        }

        return result;
    }
}
```
